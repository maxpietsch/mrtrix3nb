# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['exists', 'Comp', 'aprint']

# Cell
import os
from pathlib import Path, PurePath

def exists(s, minsize_bytes=100, isdir=False, force=False):
    # check if `s` exists (file or dir if `isdir`) and has at least `minsize_bytes` bytes
    if isdir:
        ex = os.path.isdir(s)
        if force and not ex:
            raise IOError(s)
        return ex
    if not os.path.isfile(s):
        if force: raise IOError(s)
        return False
    if isinstance(s, PurePath):
        s = str(s)
    if s.endswith('.mif') or s.endswith('.mif.gz') or s.endswith('.nii') or s.endswith('.nii.gz'):
        size = Path(s).stat().st_size
        if size < minsize_bytes:
            print(s, 'size', size, 'Bytes')
            if force:
                raise IOError(s)
            return False
    return True

# exists('/tmp')

# Cell
import os
import shutil
import logging
import subprocess
import shlex
from pathlib import Path
from collections import deque
import pprint

logging.basicConfig()

# Cell
from tqdm.auto import tqdm
import tempfile
import re

class Comp:
    def __benice(self):
        try:
            import psutil
        except ImportError:
            print('pip install psutil')
            return

        pid = os.getpid()
        ps = psutil.Process(pid)
        ps.nice(19)

    def __init__(self, dry_run=False, env=None, loglevel='INFO', progress=True, nice=False, dummy=False, path_map_dict=None):
        self.dry_run = dry_run

        self.dummy = dummy

        self.path_map = None
        self.mapped_files = dict()
        if path_map_dict is not None:
            self.path_map_dict = path_map_dict
            dirmap = path_map_dict
            keys = sorted(dirmap.keys())
            for key in keys:
                assert sum([key in k for k in keys]) == 1, f'keys must no be substrings of each other but "{key}" is'
            self.path_map = re.compile("(%s)" % "|".join(map(re.escape, dirmap.keys())))


        self.jobs = deque()

        self.logger = logging.getLogger(__name__)
        self.logger.setLevel(loglevel)

        # use directory of python binary
        python = shutil.which('python') # None if executable not found
        if python is None:
            raise ImportError("could not find python in Path")

        if env is None:
            env = os.environ.copy()
        if 'PATH' in env:
            env['PATH'] = os.pathsep.join([str(Path(python).parent), env.get('PATH')])
        self.logger.debug('env: '+pprint.pformat(env))
        self.env = env
        self.noprogress = not progress
        self.preexec_fn = None
        if nice:
            self.preexec_fn = self.__benice
        self.__tmp_dir = None


    def _execute(self, cmd):
        if not self.dry_run:
            self.logger.debug('running: ' + cmd)
            try:
                subprocess.check_call(cmd, shell=True, env=self.env, preexec_fn=self.preexec_fn)
            except:
                self.logger.warning('failed: '+str(cmd))
                raise
        else:
            self.logger.info('dry_run: ' + cmd)
        return

    def run(self):
        if not self.jobs:
            return

        if self.dummy:
            self.jobs = deque()
            return

        if not self.noprogress: pbar = tqdm(total=len(self.jobs))
        while self.jobs:
            self._execute(self.jobs.popleft())
            if not self.noprogress: pbar.update(1)
        if not self.noprogress: pbar.close()

    def __map_paths(self, x):
        if self.path_map is not None:
            x = shlex.split(x)
            newx = []
            for arg in x:
                newarg = self.path_map.sub(lambda mo: self.path_map_dict[mo.string[mo.start():mo.end()]], arg)
                if newarg not in ['|', '&&']:
                    newarg = shlex.quote(newarg)
                newx += [newarg]
                if arg != newarg:
                    if arg in self.mapped_files:
                        assert self.mapped_files[arg] == newarg
                    self.mapped_files[arg] = newarg
            return ' '.join(newx)
        return x

    def __add__(self, x):
        if isinstance(x, list):
            # convert Pathlib objects to strings
            x = [str(e) if isinstance(e, PurePath) else e for e in x]
            # join elements, but don't quote |
#             try:
#                 x = shlex.join(x)
#             except AttributeError:
            x = ' '.join([shlex.quote(w) if w != '|' and w != '&&' else w for w in x ])
        elif not isinstance(x, str):
            raise TypeError("required input is string or list of strings, received " + str(type(x)))

        x = self.__map_paths(x)

        self.logger.debug('add: '+x)
        self.jobs.append(x)
        return self

    def __iadd__(self, x):
        return self.__add__(x)

    def __repr__(self):
        return 'computer %i jobs: %s' % (self.__len__(), str(self.jobs))

    def __str__(self):
        return self.__repr__()

#     def __next__(self):
#         return self.jobs.get()

    def __len__(self):
        return len(self.jobs)

    def __enter__(self):
        self.logger.debug('Entering Comp')
        return self

    def __exit__(self, exc_type, exc, exc_tb):
        self.logger.debug('Exiting Comp')
        self.run()

    def tmp_dir(self, suffix=None, prefix=None, tmp='/tmp'):
        return tempfile.TemporaryDirectory(suffix=suffix, prefix=prefix, dir=tmp)



# Cell

def aprint(array, prefix=''):

    """ pretty print numpy array and its name

    adapted from https://stackoverflow.com/a/38434232/2389450
    """
    import re
    import numpy as np
    if prefix:
        prefix = str(prefix + ' = ')
    else:
        try:
            import inspect, ast

            frame = inspect.currentframe()
            frame = inspect.getouterframes(frame)[2]
            string = inspect.findsource(frame[0])[0]

            nodes = ast.parse(''.join(string))

            i_expr = -1
            for (i, node) in enumerate(nodes.body):
                if hasattr(node, 'value') and isinstance(node.value, ast.Call) and hasattr(node.value.func, 'id') and node.value.func.id == 'aprint':
                    i_expr = i
                    break

            i_expr_next = min(i_expr + 1, len(nodes.body)-1)
            lineno_start = nodes.body[i_expr].lineno
            lineno_end = nodes.body[i_expr_next].lineno if i_expr_next != i_expr else len(string)

            str_func_call = ''.join([i.strip() for i in string[lineno_start - 1: lineno_end]])
            params = str_func_call[len('aprint('):-1]# [str_func_call.find('(') + 1:-1].split(',')
            prefix = params + ' ='
        except:
            prefix = ''
    value_str = re.sub(r'[\[\]]', ' ', np.array2string(np.asanyarray(array), precision=6, separator=', ', max_line_width=100))
    value_str = value_str.replace('\n', '\n' + (' '*len(prefix)))

    print(prefix + value_str)